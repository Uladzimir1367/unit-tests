# unit-tests

### Урок 1. Цели и смысл тестирования

Задание 1. В классе Calculator создайте метод calculateDiscount, который принимает сумму покупки и процент скидки и возвращает сумму с учетом скидки. Ваша задача - проверить этот метод с использованием библиотеки AssertJ. Если метод calculateDiscount получает недопустимые аргументы, он должен выбрасывать исключение ArithmeticException. Не забудьте написать тесты для проверки этого поведения.

Задание 2.
Мы хотим улучшить функциональность нашего интернет-магазина. Ваша задача - добавить два новых метода в класс Shop:
Метод sortProductsByPrice(), который сортирует список продуктов по стоимости. Метод getMostExpensiveProduct(), который возвращает самый дорогой продукт. Напишите тесты, чтобы проверить, что магазин хранит верный список продуктов (правильное количество продуктов, верное содержимое корзины).
Напишите тесты для проверки корректности работы метода getMostExpensiveProduct. Напишите тесты для проверки корректности работы метода sortProductsByPrice (проверьте правильность сортировки). Используйте класс Product для создания экземпляров продуктов и класс Shop для написания методов сортировки и тестов.

### Урок 2. Знакомство с тестовыми фреймворками

Проект Vehicle. Написать следующие тесты с использованием JUnit5:

- Проверить, что экземпляр объекта Car также является экземпляром транспортного средства (используя оператор instanceof).

- Проверить, что объект Car создается с 4-мя колесами.

- Проверить, что объект Motorcycle создается с 2-мя колесами.

- Проверить, что объект Car развивает скорость 60 в режиме тестового вождения (используя метод testDrive()).

- Проверить, что объект Motorcycle развивает скорость 75 в режиме тестового вождения (используя метод testDrive()).

- Проверить, что в режиме парковки (сначала testDrive, потом park, т.е. эмуляция движения транспорта) машина останавливается (speed = 0).

- Проверить, что в режиме парковки (сначала testDrive, потом park, т.е. эмуляция движения транспорта) мотоцикл останавливается (speed = 0).

В этом проекте, вы будете работать с проектом ""Vehicle"", который представляет собой иерархию классов, включающую абстрактный базовый класс ""Vehicle"" и два его подкласса ""Car"" и ""Motorcycle"".

Базовый класс ""Vehicle"" содержит абстрактные методы ""testDrive()"" и ""park()"", а также поля ""company"", ""model"", ""yearRelease"", ""numWheels"" и ""speed"".

Класс ""Car"" расширяет ""Vehicle"" и реализует его абстрактные методы. При создании объекта ""Car"", число колес устанавливается в 4, а скорость в 0. В методе ""testDrive()"" скорость устанавливается на 60, а в методе ""park()"" - обратно в 0.

Класс ""Motorcycle"" также расширяет ""Vehicle"" и реализует его абстрактные методы. При создании объекта ""Motorcycle"", число колес устанавливается в 2, а скорость в 0. В методе ""testDrive()"" скорость устанавливается на 75, а в методе ""park()"" - обратно в 0.

### Урок 3. Качество тестов

*Задание 1.

Напишите тесты, покрывающие на 100% метод evenOddNumber, который проверяет, является ли переданное число четным или нечетным. (код приложен в презентации)

Задание 2.

Разработайте и протестируйте метод numberInInterval, который проверяет, попадает ли переданное число в интервал (25;100). (код приложен в презентации)

Задание 3.  (необязательное)

Добавьте функцию в класс UserRepository, которая разлогинивает всех пользователей, кроме администраторов. Для этого, вам потребуется расширить класс User новым свойством, указывающим, обладает ли пользователь админскими правами. Протестируйте данную функцию.

   ### Урок 4.
  ### Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

__Тестовые заглушки__ позволяют изолировать тестируемый модуль от других зависимостей, что упрощает обнаружение и устранение ошибок.

Заглушки могут заменить сложные или медленные части кода, что ускоряет выполнение тестов и позволяет быстрее получать результаты.

Заглушками можно заменить код, который сложно или невозможно протестировать напрямую, что позволяет улучшить покрытие тестами и выявить больше потенциальных ошибок.

### Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными аргументами?

__Тестовая заглушка__, которая сохраняет информацию о переданных аргументах.<br> К примеру: можно использовать mock-объект, который поддерживает метод проверки того, были ли заданы определенные аргументы при вызове метода.

### Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение в ответ на вызов метода?

Если вам просто нужно вернуть определённое значение или выбросить исключение в ответ на вызов некоторого метода, то вы можете использовать простую функцию или lambda-выражение в качестве заглушки.<br>
* Для простого возвращения определенного значения или исключения можно использовать stub объекты. Они подменяют реальный компонент, возвращая предопределенные значения 

### Какой тип тестовой заглушки вы бы использовали для имитации взаимодействия с внешним API или базой данных?

Можно использовать mock-объекты, которые позволяют контролировать, какие вызовы методов были сделаны и какие возвращаемые значения были получены. Это помогает изолировать тестируемый код от внешних зависимостей и упрощает процесс тестирования.<br>      
- Предпочтительней использовать *fake объекты* - это заглушки, которые реализуют упрощенную версию реального объекта или интерфейса. Они могут использоваться для имитации внешних зависимостей, таких как база данных или внешнее API. 


### Урок 5. Другие виды тестирования

#### Задание 1. *Представьте, что вы работаете над разработкой простого приложения для записной книжки, которое позволяет пользователям добавлять, редактировать и удалять контакты.

Ваша задача - придумать как можно больше различных тестов (юнит-тесты, интеграционные тесты, сквозные тесты) для этого приложения. Напишите название каждого теста, его тип и краткое описание того, что этот тест проверяет.

__Модульные тесты (юнит-тесты)__

1. | Добавить контакт - (test_add_contact()) |<br> 
Проверка: функция добавления контакта работает корректно.|

2. | Редактировать контакт - (test_edit_contact()) |<br> Проверка: функция редактирования контакта изменяет данные корректно. |

3. | Удалить контакт (test_delete_contact()) |<br> Проверка: функция удаления контакта удаляет контакт из хранилища(БД).|

4. | Определение валидности номера телефона(test_valid_phone()) |<br> Проверка: номер телефона введён корректно.|

5. | Определение валидности адреса email (test_valid_email()) |<br> Проверка: функция добавления контакта корректно обрабатывает адрес электронной почты.|

6. |Тест на дублирование контактов (test_duplicate_contact()) | <br> Проверка: добавление контакта с уже существующим именем вызывает соответствующее исключение.|

7. |Тест на пустые данные поля имени (test_empty_name())| <br> Проверка: добавление контакта с пустым полем имени вызывает соответствующее исключение.|

8. | Удалить все контакты (test_delete_all_contacts()).| <br>  Проверка: удаление всех контактов работает корректно.|

__Интеграционные тесты__

1. |Добавление и просмотр контакта (test_add_and_view_contact()). |<br> Проверка: процесс добавления контакта и его последующего просмотра работает корректно.|

2. |Добавление и редактирование контакта (test_add_and_edit_contact()).| <br> Проверка: процесс добавления контакта и последующего его редактирования работает корректно.|

3. |Добавление и удаление контакта (test_add_and_delete_contact())|<br> Проверка: процесс добавления, удаления контакта работает корректно.|

4. | Добавление и поиск контакта (test_add_and_search_contact()).|<br> Проверка:  процесс добавления контакта, поиска контакта работает корректно.

5. | Редактирование и удаление контакта (test_edit_and_delete_contact()).|<br> Проверка:  процесс редактирования, удаления контакта работает корректно.|

6. | Удаление и восстановление контакта (test_delete_and_restore_contact()). |<br> Проверка:  процесс удаления и последующего восстановления контакта работает корректно. |

7. | Добавление контакта и получение всех контактов (test_add_contact_and_get_all()).|<br> Проверка:  после добавления нового контакта, список всех контактов обновлён.|

__Сквозные тесты (End-to-End тесты)__

1. Поиск Контакта (test_search_contact(initial_contact_data))<br> Проверка: функция поиска контакта в приложении работает корректно - отображаются все поля найденного контакта.

2. Добавление, просмотр и удаление контакта (test_add_view_and_delete_contact(initial_contact_data))<br> Проверка: весь процесс добавления, просмотра и удаления контакта работает корректно.

3. Добавление, редактирование и последующее удаление контакта (test_add_edit_and_delete_contact(initial_contact_data)) <br> Проверка: тест создает контакт, редактирует его данные, удаляет контакт.


#### Задание 2. *Ниже список тестовых сценариев. Ваша задача - определить тип каждого теста (юнит-тест, интеграционный тест, сквозной тест) и объяснить, почему вы так решили.
*. Проверка того, что функция __addContact__ корректно добавляет новый контакт в список контактов"".<br>
*. ""Проверка того, что при добавлении контакта через пользовательский интерфейс, контакт корректно отображается в списке контактов"".<br>
*. ""Проверка полного цикла работы с контактом: создание контакта, его редактирование и последующее удаление"".<br>

1. __Юнит-тест.__  Проверяет конкретную функциональность - добавление контакта - включает в себя все необходимые проверки, что функция работает правильно. В реализации приложения для записной книжки - это метод test_add_contact()<br> 
   Т.Е. - функция __test_add_contact__ корректно добавляет новый контакт в список контактов. 

2. __Интеграционный тест.__  Тест проверяет взаимодействие различных частей системы друг с другом, между пользовательским интерфейсом и внутренним функционалом приложения. <br> При добавлении контакта через пользовательский интерфейс, контакт корректно отображается в списке контактов. Т.Е. __test_add_and_view_contact()__

3. __Сквозной тест.__ Охватывает все этапы работы с контактом, проверяет каждый этап.<br> Осуществляет проверку полного цикла работы с контактом: создание контакта, его редактирование и последующее удаление.<br> Метод __test_add_edit_and_delete_contact(initial_contact_data)__